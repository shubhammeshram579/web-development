<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>basic of undertanding recusion</h1>




    <script>

        // Recursion is a concept in programming where a function calls itself to solve smaller instances of the same problem until a base condition is met, at which point the recursion stops. It is often used for problems that can be divided into similar sub-problems, like factorial calculation, searching algorithms (like binary search), tree traversal, etc.

        // Basic Recursion Example: Factorial
        // Problem: Calculate the factorial of a number using recursion.

        // The factorial of a number n is the product of all positive integers less than or equal to n. It is denoted as n!.

        // Code:
        // javascript
        // Copy code
        // function factorial(n) {
        //     // Base case: factorial of 0 or 1 is 1
        //     if (n === 0 || n === 1) {
        //         return 1;
        //     }
        //     // Recursive case: n * factorial of (n-1)
        //     return n * factorial(n - 1);
        // }

        // // Test the function
        // console.log(factorial(5)); // Output: 120
        // Explanation:

        // Base case: When n is 0 or 1, the function returns 1 because 0! = 1! = 1.
        // Recursive case: The function calls itself with n - 1 until it reaches the base case.
        // Intermediate Example: Fibonacci Sequence
        // Problem: Write a recursive function to find the nth number in the Fibonacci sequence.

        // The Fibonacci sequence starts with 0 and 1, and every number after that is the sum of the two preceding ones: 0, 1, 1, 2, 3, 5, 8, 13....

        // Code:
        // javascript
        // Copy code
        // function fibonacci(n) {
        //     // Base case: return n if n is 0 or 1
        //     if (n === 0 || n === 1) {
        //         return n;
        //     }
        //     // Recursive case: fibonacci(n-1) + fibonacci(n-2)
        //     return fibonacci(n - 1) + fibonacci(n - 2);
        // }

        // // Test the function
        // console.log(fibonacci(6)); // Output: 8
        // Explanation:

        // Base case: If n is 0 or 1, the function returns n (because fib(0) = 0 and fib(1) = 1).
        // Recursive case: For n > 1, the function calls itself for the two preceding numbers (n-1 and n-2) and sums them up.
        // Advanced Example: Tower of Hanoi
        // Problem: Solve the Tower of Hanoi problem using recursion.

        // The Tower of Hanoi is a classic problem where you have three rods and a number of disks of different sizes. The objective is to move all disks from one rod to another, following these rules:

        // Only one disk can be moved at a time.
        // A disk can only be moved to the top of another rod or an empty rod.
        // A larger disk cannot be placed on top of a smaller disk.
        // Code:
        // javascript
        // Copy code
        // function towerOfHanoi(n, fromRod, toRod, auxRod) {
        //     // Base case: If only 1 disk, move it from source to target rod
        //     if (n === 1) {
        //         console.log(`Move disk 1 from rod ${fromRod} to rod ${toRod}`);
        //         return;
        //     }
        //     // Move top n-1 disks from 'fromRod' to 'auxRod' using 'toRod'
        //     towerOfHanoi(n - 1, fromRod, auxRod, toRod);
            
        //     // Move the nth disk from 'fromRod' to 'toRod'
        //     console.log(`Move disk ${n} from rod ${fromRod} to rod ${toRod}`);
            
        //     // Move the n-1 disks from 'auxRod' to 'toRod' using 'fromRod'
        //     towerOfHanoi(n - 1, auxRod, toRod, fromRod);
        // }

        // // Test the function with 3 disks
        // towerOfHanoi(3, 'A', 'C', 'B');
        // Output:

        // css
        // Copy code
        // Move disk 1 from rod A to rod C
        // Move disk 2 from rod A to rod B
        // Move disk 1 from rod C to rod B
        // Move disk 3 from rod A to rod C
        // Move disk 1 from rod B to rod A
        // Move disk 2 from rod B to rod C
        // Move disk 1 from rod A to rod C
        // Explanation:

        // Base case: If there is only one disk (n === 1), just move it from the source rod to the target rod.
        // Recursive case:
        // First, move the top n-1 disks from the source rod to the auxiliary rod.
        // Then, move the nth disk from the source rod to the target rod.
        // Finally, move the n-1 disks from the auxiliary rod to the target rod.
        // Tail Recursion (Optimized Recursion)
        // Problem: Write a tail-recursive factorial function.

        // Tail recursion is an optimized form of recursion where the recursive call is the last operation in the function. This allows some compilers or interpreters to optimize and reduce the memory usage.

        // Code:
        // javascript
        // Copy code
        // function tailFactorial(n, accumulator = 1) {
        //     // Base case
        //     if (n === 0) {
        //         return accumulator;
        //     }
        //     // Tail-recursive call: pass n-1 and accumulate the result
        //     return tailFactorial(n - 1, n * accumulator);
        // }

        // // Test the function
        // console.log(tailFactorial(5)); // Output: 120
        // Explanation:

        // Instead of waiting for the result of factorial(n-1) and then multiplying, the result is accumulated in an accumulator variable and passed down through each recursive call, making the recursion more efficient.
    </script>
</body>
</html>